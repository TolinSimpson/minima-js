let currentComponent=null;let hookIndex=0;let components=new WeakMap();const depsEqual=(a,b)=>{if(!a||!b)return a===b;if(a.length!==b.length)return false;for(let i=0;i<a.length;i++){if(a[i]!==b[i])return false;}return true;};let renderQueue=new Set();let isRendering=false;const PRIORITIES={IMMEDIATE:0,NORMAL:1,IDLE:2};let currentTransition=null;let pendingTransitions=new Set();let suspenseCache=new Map();let currentSuspenseHandler=null;const createElement=(type,props={},...children)=>{const flatChildren=children.flat();const vnodeProps=props&&Object.keys(props).length>0?{...props,children:flatChildren}:{children:flatChildren};const vnode={type,props:vnodeProps,key:props?.key||null};if(flatChildren.length>1){const keys=new Set();for(let i=0;i<flatChildren.length;i++){const child=flatChildren[i];if(child?.key){if(keys.has(child.key)){console.warn('createElement:Duplicate keys detected in children.This may cause rendering issues.');break;}keys.add(child.key);}}}return vnode;};const useState=(initial)=>{if(!currentComponent)throw new Error('useState:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(comp.hooks[idx]===undefined)comp.hooks[idx]={state:initial};const setState=(newState)=>{const hook=comp.hooks[idx];const value=typeof newState==='function'?newState(hook.state):newState;if(hook.state!==value){hook.state=value;scheduleRender(currentComponent);}};return[comp.hooks[idx].state,setState];};const useEffect=(effect,deps)=>{if(!currentComponent)throw new Error('useEffect:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(!comp.hooks[idx])comp.hooks[idx]={};const hook=comp.hooks[idx];const depsChanged=!depsEqual(hook.deps,deps);if(depsChanged){if(hook.cleanup)hook.cleanup();hook.cleanup=effect();hook.deps=deps;}if(!comp.cleanup){comp.cleanup=()=>{comp.hooks?.forEach(h=>h.cleanup?.());};}};const useMemo=(factory,deps)=>{if(!currentComponent)throw new Error('useMemo:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(!comp.hooks[idx])comp.hooks[idx]={};const hook=comp.hooks[idx];if(!depsEqual(hook.deps,deps)){hook.value=factory();hook.deps=deps;}return hook.value;};const useCallback=(callback,deps)=>{if(!currentComponent)throw new Error('useCallback:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(!comp.hooks[idx])comp.hooks[idx]={};const hook=comp.hooks[idx];if(!depsEqual(hook.deps,deps)){hook.callback=callback;hook.deps=deps;}return hook.callback;};const useTransition=()=>{if(!currentComponent)throw new Error('useTransition:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(!comp.hooks[idx])comp.hooks[idx]={isPending:false};const hook=comp.hooks[idx];const startTransition=(callback)=>{const transition={id:Math.random().toString(36).substr(2,9),priority:PRIORITIES.NORMAL,callback,startTime:performance.now()};currentTransition=transition;pendingTransitions.add(transition);hook.isPending=true;try{callback();}finally{pendingTransitions.delete(transition);if(pendingTransitions.size===0){currentTransition=null;}hook.isPending=false;}};return[hook.isPending,startTransition];};const useDeferredValue=(value)=>{if(!currentComponent)throw new Error('useDeferredValue:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(!comp.hooks[idx])comp.hooks[idx]={};const hook=comp.hooks[idx];if(hook.deferredValue!==value){hook.deferredValue=value;scheduleRender(currentComponent);}return hook.deferredValue;};const useResource=(resourceFactory)=>{if(!currentComponent)throw new Error('useResource:outside component');const comp=components.get(currentComponent);const idx=hookIndex++;if(!comp.hooks)comp.hooks=[];if(!comp.hooks[idx])comp.hooks[idx]={};const hook=comp.hooks[idx];if(!hook.result){hook.result=resourceFactory();}return hook.result;};const Suspense=({children,fallback})=>{const prevSuspenseHandler=currentSuspenseHandler;currentSuspenseHandler=()=>fallback;try{return children;}catch(promise){if(promise&&typeof promise.then==='function'){return fallback;}throw promise;}finally{currentSuspenseHandler=prevSuspenseHandler;}};const scheduleRender=(component)=>{renderQueue.add(component);if(!isRendering){isRendering=true;if(typeof requestIdleCallback!=='undefined'){requestIdleCallback(()=>{renderQueue.forEach(comp=>renderComponent(comp));renderQueue.clear();isRendering=false;},{timeout:100});}else{setTimeout(()=>{renderQueue.forEach(comp=>renderComponent(comp));renderQueue.clear();isRendering=false;},0);}}};const diff=(oldVNode,newVNode,container,index=0)=>{if(!newVNode&&oldVNode){container.removeChild(container.childNodes[index]);if(oldVNode.type&&typeof oldVNode.type==='function'){const comp=components.get(oldVNode.type);if(comp?.cleanup)comp.cleanup();}return;}if(newVNode&&!oldVNode){container.appendChild(createDOMElement(newVNode));return;}if(oldVNode.type!==newVNode.type){container.replaceChild(createDOMElement(newVNode),container.childNodes[index]);return;}if(typeof newVNode==='string'||typeof newVNode==='number'){if(oldVNode!==newVNode){container.childNodes[index].textContent=newVNode;}return;}const node=container.childNodes[index];updateProps(node,oldVNode.props,newVNode.props);const oldChildren=oldVNode.props.children||[];const newChildren=newVNode.props.children||[];const oldKeyed=new Map();const oldKeyless=[];oldChildren.forEach((child,i)=>{const key=child?.key;if(key)oldKeyed.set(key,{child,index:i});else oldKeyless.push({child,index:i});});const newKeyed=new Map();const newKeyless=[];newChildren.forEach((child,i)=>{const key=child?.key;if(key)newKeyed.set(key,{child,index:i});else newKeyless.push({child,index:i});});const allKeys=new Set([...oldKeyed.keys(),...newKeyed.keys()]);allKeys.forEach(key=>{const old=oldKeyed.get(key);const nw=newKeyed.get(key);if(!nw){if(old){const domIndex=findDOMIndex(node,old.index);if(domIndex>=0){node.removeChild(node.childNodes[domIndex]);}}}else if(!old){const beforeKey=findBeforeKey(newKeyed,key);const beforeIndex=beforeKey?findDOMIndex(node,newKeyed.get(beforeKey).index):-1;const domElement=createDOMElement(nw.child);if(beforeIndex>=0){node.insertBefore(domElement,node.childNodes[beforeIndex]);}else{node.appendChild(domElement);}}else{diff(old.child,nw.child,node,old.index);}});const maxKeyless=Math.max(oldKeyless.length,newKeyless.length);for(let i=0;i<maxKeyless;i++){const oldChild=oldKeyless[i]?.child;const newChild=newKeyless[i]?.child;diff(oldChild,newChild,node,oldKeyless[i]?.index??i);}};const findDOMIndex=(parent,vnodeIndex)=>{const children=Array.from(parent.childNodes);let domIndex=0;for(let i=0;i<vnodeIndex&&domIndex<children.length;i++){domIndex++;}return domIndex<children.length?domIndex:-1;};const findBeforeKey=(keyedMap,targetKey)=>{const keys=Array.from(keyedMap.keys());const targetIndex=keys.indexOf(targetKey);for(let i=targetIndex-1;i>=0;i--){if(keyedMap.has(keys[i]))return keys[i];}return null;};const createDOMElement=(vnode)=>{if(typeof vnode==='string'||typeof vnode==='number'){return document.createTextNode(vnode);}if(typeof vnode.type==='function'){return renderFunction(vnode);}const element=document.createElement(vnode.type);updateProps(element,{},vnode.props);(vnode.props.children||[]).forEach(child=>{if(child!=null)element.appendChild(createDOMElement(child));});return element;};const renderFunction=(vnode)=>{const comp=vnode.type;const prevComponent=currentComponent;const prevHookIndex=hookIndex;currentComponent=comp;hookIndex=0;if(!components.has(comp)){components.set(comp,{element:null,oldVNode:null,props:vnode.props});}const compData=components.get(comp);const rendered=comp(vnode.props);if(!compData.element){compData.element=createDOMElement(rendered);compData.oldVNode=rendered;}currentComponent=prevComponent;hookIndex=prevHookIndex;return compData.element;};const renderComponent=(comp)=>{const compData=components.get(comp);if(!compData.element)return;const prevComponent=currentComponent;const prevHookIndex=hookIndex;currentComponent=comp;hookIndex=0;const newVNode=comp(compData.props);const parentNode=compData.element.parentNode;const siblings=parentNode.childNodes;let elementIndex=0;for(;elementIndex<siblings.length&&siblings[elementIndex]!==compData.element;elementIndex++);diff(compData.oldVNode,newVNode,parentNode,elementIndex);compData.oldVNode=newVNode;currentComponent=prevComponent;hookIndex=prevHookIndex;};const updateProps=(element,oldProps={},newProps={})=>{const oldKeys=Object.keys(oldProps);const newKeys=Object.keys(newProps);for(let i=0;i<oldKeys.length;i++){const key=oldKeys[i];if(key==='children'||key in newProps)continue;if(key.startsWith('on')){element.removeEventListener(key.substring(2).toLowerCase(),oldProps[key]);}else if(key in element){element[key]='';}else{element.removeAttribute(key);}}for(let i=0;i<newKeys.length;i++){const key=newKeys[i];if(key==='children')continue;const oldValue=oldProps[key];const newValue=newProps[key];if(oldValue!==newValue){if(key.startsWith('on')){const event=key.substring(2).toLowerCase();if(oldValue)element.removeEventListener(event,oldValue);element.addEventListener(event,newValue);}else if(key in element){element[key]=newValue;}else{element.setAttribute(key,newValue);}}}};const render=(vnode,container)=>{if(container._minimaVNode){diff(container._minimaVNode,vnode,container,0);}else{container.appendChild(createDOMElement(vnode));}container._minimaVNode=vnode;};export{createElement,useState,useEffect,useMemo,useCallback,useTransition,useDeferredValue,useResource,Suspense,render};